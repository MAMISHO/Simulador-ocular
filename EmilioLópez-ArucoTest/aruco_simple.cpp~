#include <iostream>
#include <fstream>
#include <sstream>
#include "aruco.h"
#include <aruco/aruco.h>
#include "cvdrawingutils.h"
#include <opencv2/highgui/highgui.hpp>
#include <string>
#include <cstdlib>
#include <cstdio>
#include <opencv2/core.hpp>
#include <opencv2/imgproc.hpp>
using namespace cv;
using namespace aruco;

string TheInputVideo;
string TheIntrinsicFile;
VideoCapture TheVideoCapturer;
Mat TheInputImage, TheInputImageCopy;
CameraParameters TheCameraParameters;
float TheMarkerSize = -1;
int waitTime = 0;
vector< Marker > TheMarkers;
int ThePyrDownLevel;
MarkerDetector MDetector;
double ThresParam1, ThresParam2;
int iThresParam1, iThresParam2;
pair< double, double > AvrgTime(0, 0);
void cvTackBarEvents(int pos, void *);

float *convertToFloat(Marker marker);
void MyFilledCircle( Mat img, Point center );

int main(int argc, char const *argv[])
{
	float *vMarker = new float[8];
    // comprueba argumentos
    if(argc < 2){
        cerr << "Uso: ./aruco_simple live camera.yml [size]" << endl;
        return 0;
    }

    else{
        TheInputVideo = argv[1];
        TheIntrinsicFile = argv[2];
        TheMarkerSize = atof(argv[3]);
        cout << "Todo correctimer" << endl;
    }

    // lectura por cámara
    if(TheInputVideo.find("live") != string::npos){
        int vIdx=0;
        char cad[100];

        cout << "Abriendo cámara" << vIdx << endl;
        TheVideoCapturer.open(vIdx);
        waitTime=10;
    }

    bool isVideoFile = false;
        if (TheInputVideo.find(".avi") != std::string::npos || TheInputVideo.find("live") != string::npos)
            isVideoFile = true;
        // read first image to get the dimensions
        TheVideoCapturer >> TheInputImage;
    
        // read camera parameters if passed
        if (TheIntrinsicFile != "") {
            TheCameraParameters.readFromXMLFile(TheIntrinsicFile);
            TheCameraParameters.resize(TheInputImage.size());
        }
        // Configure other parameters
        if (ThePyrDownLevel > 0)
            MDetector.pyrDown(ThePyrDownLevel);

        // Create gui

        cv::namedWindow("thres", 1);
        cv::namedWindow("in", 1);

        MDetector.setThresholdParams(7, 7);
        MDetector.setThresholdParamRange(2, 0);
        //  MDetector.enableLockedCornersMethod(true);
        //         MDetector.setCornerRefinementMethod ( MarkerDetector::SUBPIX );
        MDetector.getThresholdParams(ThresParam1, ThresParam2);
        iThresParam1 = ThresParam1;
        iThresParam2 = ThresParam2;
        cv::createTrackbar("ThresParam1", "in", &iThresParam1, 25, cvTackBarEvents);
        cv::createTrackbar("ThresParam2", "in", &iThresParam2, 13, cvTackBarEvents);

        char key = 0;
        int index = 0;
        // capture until press ESC or until the end of the video
        TheVideoCapturer.retrieve(TheInputImage);

        do {

            // copy image

            index++; // number of images captured
            double tick = (double)getTickCount(); // for checking the speed
            // Detection of markers in the image passed
            MDetector.detect(TheInputImage, TheMarkers, TheCameraParameters, TheMarkerSize);
            // chekc the speed by calculating the mean speed of all iterations
            AvrgTime.first += ((double)getTickCount() - tick) / getTickFrequency();
            AvrgTime.second++;
            cout << "\rTime detection=" << 1000 * AvrgTime.first / AvrgTime.second << " milliseconds nmarkers=" << TheMarkers.size() << std::flush;

            // print marker info and draw the markers in image
            TheInputImage.copyTo(TheInputImageCopy);

            for (unsigned int i = 0; i < TheMarkers.size(); i++) {
                cout << endl << TheMarkers[i];
                //TheMarkers[i].draw(TheInputImageCopy, Scalar(0, 0, 255), 1);
		vMarker=convertToFloat(TheMarkers[i]);
            	float ancho=(vMarker[2]-vMarker[0])/2;
            	float alto=(vMarker[1]-vMarker[7])/2;
            	MyFilledCircle(TheInputImage,Point(vMarker[6]+ancho,vMarker[7]+alto));
            }
            //if (TheMarkers.size() != 0)
             //   cout << endl;
               /*if (TheCameraParameters.isValid())
                for (unsigned int i = 0; i < TheMarkers.size(); i++) {
                    cvCircle(TheInputImageCopy, TheMarkers[i], TheCameraParameters);
                }
*/
            // DONE! Easy, right?
            // show input with augmented information and  the thresholded image
            cv::imshow("in", TheInputImageCopy);
            cv::imshow("thres", MDetector.getThresholdedImage());

            key = cv::waitKey(waitTime); // wait for key to be pressed
            if (isVideoFile)
                TheVideoCapturer.retrieve(TheInputImage);

        } while (key != 27 && (TheVideoCapturer.grab() || !isVideoFile));
}

void cvTackBarEvents(int pos, void *) {
    if (iThresParam1 < 3)
        iThresParam1 = 3;
    if (iThresParam1 % 2 != 1)
        iThresParam1++;
    if (ThresParam2 < 1)
        ThresParam2 = 1;
    ThresParam1 = iThresParam1;
    ThresParam2 = iThresParam2;
    MDetector.setThresholdParams(ThresParam1, ThresParam2);
    // recompute
    MDetector.detect(TheInputImage, TheMarkers, TheCameraParameters);
    TheInputImage.copyTo(TheInputImageCopy);
    for (unsigned int i = 0; i < TheMarkers.size(); i++)
        TheMarkers[i].draw(TheInputImageCopy, Scalar(0, 0, 255), 1);
    // print other rectangles that contains no valid markers
    /*for (unsigned int i=0;i<MDetector.getCandidates().size();i++) {
        aruco::Marker m( MDetector.getCandidates()[i],999);
        m.draw(TheInputImageCopy,cv::Scalar(255,0,0));
    }*/

    // draw a 3d cube in each marker if there is 3d info
    if (TheCameraParameters.isValid())
        for (unsigned int i = 0; i < TheMarkers.size(); i++)
            CvDrawingUtils::draw3dCube(TheInputImageCopy, TheMarkers[i], TheCameraParameters);

    cv::imshow("in", TheInputImageCopy);
    cv::imshow("thres", MDetector.getThresholdedImage());
}

float *convertToFloat(Marker marker){
    char cadena[128];
    int pos1,pos2;
    float *vFloat = new float[8];
    string p1;
    for(int i=0;i<4;i++){
        //OBTENEMOS EL VALOR X DEL PUNTO
        cout<<marker[i]<<endl;
        ofstream fs("nombre.txt");
        //guardamos el punto en el fichero
        fs << marker[i] <<endl;
        fs.close();
        ifstream fe("nombre.txt");
        //leemos el punto y lo asignamos a una cadena
        fe.getline(cadena,128);
        //pasamos la cadena de char* a string
        string p1=cadena;
        pos1=p1.find('[');
        pos2=p1.find(',');
        //obtenemos el valor x de toda la cadena
        string c1=p1.substr(pos1+1,(pos2-pos1)-1);
        char cadenad[20];
        strcpy(cadenad,c1.c_str());
        vFloat[2*i]=std::atof(cadenad);

        //OBTENEMOS EL VVALOR Y DEL PUNTO
        int pos3=p1.find(']');
        c1=p1.substr(pos2+1,(pos3-pos2)-1);
        strcpy(cadenad,c1.c_str());
        vFloat[2*i+1]=std::atof(cadenad);
    }

    return vFloat;
}

void MyFilledCircle( Mat img, Point center )
{
  int thickness = -1;
  int lineType = 8;

  circle( img,
      center,
      400/32,
      Scalar( 0, 0, 255 ),
      thickness,
      lineType );
}
